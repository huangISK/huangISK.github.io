<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="蓦然回首，那是我们逝去的青春">
<meta property="og:type" content="website">
<meta property="og:title" content="Human Instrumentality Project">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Human Instrumentality Project">
<meta property="og:description" content="蓦然回首，那是我们逝去的青春">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Alexior">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Human Instrumentality Project</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Human Instrumentality Project</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/17/SpringMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alexior">
      <meta itemprop="description" content="蓦然回首，那是我们逝去的青春">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Human Instrumentality Project">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/17/SpringMVC/" class="post-title-link" itemprop="url">SpringMVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-17 08:52:52" itemprop="dateCreated datePublished" datetime="2023-03-17T08:52:52+08:00">2023-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-19 17:43:13" itemprop="dateModified" datetime="2023-03-19T17:43:13+08:00">2023-03-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-什么是Spring-MVC"><a href="#一-什么是Spring-MVC" class="headerlink" title="一.什么是Spring MVC"></a>一.什么是Spring MVC</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>
&emsp;&emsp;
【官网】Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning. The formal name, "Spring Web MVC," comes from the name of its source module (spring-webmvc), but it is more commonly known as "Spring MVC".<br>
&emsp;&emsp;
【翻译】Spring Web MVC是基于 Servlet API 构建的轻量级原始 Web 框架，从一开始就包含在 Spring 框架中。正式名称 Spring Web MVC 来自其源模块（spring-webmvc）的名称，但更常见的名称是 Spring MVC。<br>
&emsp;&emsp;
Spring MVC 通过把<strong>模型-视图-控制器</strong>分离，将web层进行职责解耦，方便开发。
</p>

<h2 id="2-请求执行流程"><a href="#2-请求执行流程" class="headerlink" title="2.请求执行流程"></a>2.请求执行流程</h2><img src="\images\pic.png" width= 700 height=512 />

<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/spring_mvc/process.html">图片来源</a><br>【注意】springmvc是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的，解决方案是在控制器里面不能写字段。</li>
</ul>
<h1 id="二-DispatcherServlet"><a href="#二-DispatcherServlet" class="headerlink" title="二.DispatcherServlet"></a>二.DispatcherServlet</h1><img src="\images\pic1.png" width= 800 height=512 />

<p>DispatcherServlet入口：</p>
<ul>
<li>init()：<br>加载web.xml中DispatcherServlet配置，调用initServletBean()（继承父类）。</li>
<li>initServletBean()：<br>调用initWebApplicationContext()（继承父类）。</li>
<li>initWebApplicationContext()：<br>初始化IOC容器，调用createWebApplicationContext方法（继承父类）。</li>
<li>createWebApplicationContext(WebApplicationContext)：<br>获取或生成容器，调用onRefresh方法。</li>
<li>onRefresh(ApplicationContext)：<br>用于在ApplicationContext刷新后进行策略组件的初始化。</li>
<li><strong>initStrategies(ApplicationContext)</strong> ：<br>初始化9个策略组件。</li>
<li>doService()：<br>设置request的相关属性。</li>
<li>doDispatch()：<br>DispatcherServlet获取HandlerMapping和HandlerAdapter。</li>
<li>processDispatchResult(processedRequest, response, mappedHandler, mv,dispatchException)<br>异常分析，存在ModelAndView后调用render方法进行渲染，渲染完成后调用HandlerInterceptor拦截器的afterCompletion方法。</li>
<li>render():<br>解析视图名称获取对应View，调用View的render方法通过Model来渲染视图。</li>
</ul>
<h1 id="三-SpringMVC的九大组件"><a href="#三-SpringMVC的九大组件" class="headerlink" title="三.SpringMVC的九大组件"></a>三.SpringMVC的九大组件</h1><ol>
<li>HandlerMapping<br>根据request找到相应的处理器。因为Handler（Controller）有两种形式，一种是基于类的Handler，另一种是基于Method的Handler（也就是我们常用的）。</li>
<li>HandlerAdapter<br>调用Handler的适配器。如果把Handler（Controller）当做工具的话，那么HandlerAdapter就相当于干活的工人。</li>
<li>HandlerExceptionResolver<br>对异常的处理。</li>
<li>ViewResolver<br>用来将String类型的视图名和Locale解析为View类型的视图。</li>
<li>RequestToViewNameTranslator<br>有的Handler（Controller）处理完后没有设置返回类型，比如是void方法，这是就需要从request中获取viewName。</li>
<li>LocaleResolver<br>从request中解析出Locale。Locale表示一个区域，比如zh-cn，对不同的区域的用户，显示不同的结果，这就是i18n（SpringMVC中有具体的拦截器LocaleChangeInterceptor）。</li>
<li>ThemeResolver<br>主题解析，这种类似于我们手机更换主题，不同的UI，css等。</li>
<li>MultipartResolver<br>处理上传请求，将普通的request封装成MultipartHttpServletRequest。</li>
<li>FlashMapManager<br>用于管理FlashMap，FlashMap用于在redirect重定向中传递参数。</li>
</ol>
<h1 id="四-HandlerMapping"><a href="#四-HandlerMapping" class="headerlink" title="四.HandlerMapping"></a>四.HandlerMapping</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>
&emsp;&emsp;
HandlerMapping 功能就是根据请求匹配到对应的 Handler，然后将找到的 Handler 和所有匹配的 HandlerInterceptor（拦截器）绑定到创建的 HandlerExecutionChain 对象上并返回。<br>
&emsp;&emsp;
HandlerMapping 只是一个接口类，不同的实现类有不同的匹对方式，根据功能的不同我们需要在 SpringMVC 容器中注入不同的映射处理器 HandlerMapping。<br>
&emsp;&emsp;
我们常见的No mapping found for HTTP request with URI……错误也是因为HandlerMapping没有找到对应handler。
</p>

<h2 id="2-dispatchServlet的初始化"><a href="#2-dispatchServlet的初始化" class="headerlink" title="2.dispatchServlet的初始化"></a>2.dispatchServlet的初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void initHandlerMappings(ApplicationContext context) &#123;</span><br><span class="line">	容器被初始化的时候会被调用，加载容器中注入的 HandlerMapping。</span><br><span class="line">   其实常用到的 HandlerMapping 都是由 &lt;mvc:annotation-driven /&gt; 标签帮我们注册的(包括 RequestMappingHandlerMapping 和 BeanNameUrlHandlerMapping)，</span><br><span class="line">   如果没有写该标签系统也会帮我们注入默认的映射器，当然也有些需要我们自己手动注入。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>
&emsp;&emsp;
HandlerMapping 接口中只有一个方法getHandler。DispatcherServlet在处理请求得时候，会调用AbstractHandlerMapping的getHandler()方法将通用拦截器以及根据Url匹配得拦截器放入集合中，最后将handle处理器和拦截器集合封装成HandlerExecutionChain对象返回：
</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override </span><br><span class="line">@Nullable </span><br><span class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception&#123;</span><br><span class="line">  // &lt;1&gt; 获得处理器（HandlerMethod 或者 HandlerExecutionChain），该方法是抽象方法，由子类实现 </span><br><span class="line">  Object handler = getHandlerInternal(request); </span><br><span class="line">  // &lt;2&gt; 获得不到，则使用默认处理器 </span><br><span class="line">  // &lt;3&gt; 还是获得不到，则返回 null </span><br><span class="line">  // &lt;4&gt; 如果找到的处理器是 String 类型，则从 Spring 容器中找到对应的 Bean 作为处理器 </span><br><span class="line">  // &lt;5&gt; 创建 HandlerExecutionChain 对象（包含处理器和拦截器） </span><br><span class="line">  // ... </span><br><span class="line"><span class="built_in">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
【注】getHandlerInternal(HttpServletRequest request) 抽象方法，获取请求对应的处理器，该方法由子类去实现。
## 3.HandlerMapping接口
<img src="\images\pc2.png" width= 852 height=512 />

<h3 id="4-BeanNameUrlHandlerMapping"><a href="#4-BeanNameUrlHandlerMapping" class="headerlink" title="4.BeanNameUrlHandlerMapping"></a>4.BeanNameUrlHandlerMapping</h3><p>该实现类可以把容器中name以”&#x2F;“ 开头的Bean注册为handler。在xml文件中注册：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;/hello.html&quot;</span> class=<span class="string">&quot;com.xxx.controller.HelloController&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-SimpleUrlHandlerMapping"><a href="#5-SimpleUrlHandlerMapping" class="headerlink" title="5.SimpleUrlHandlerMapping"></a>5.SimpleUrlHandlerMapping</h3><p>在xml文件中注册：<br><strong>prop key方式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans ...&gt; </span><br><span class="line">    &lt;bean class=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;mappings&quot;</span>&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">           &lt;prop key=<span class="string">&quot;/welcome.htm&quot;</span>&gt;welcomeController&lt;/prop&gt;</span><br><span class="line">           &lt;prop key=<span class="string">&quot;/*/welcome.htm&quot;</span>&gt;welcomeController&lt;/prop&gt;</span><br><span class="line">           &lt;prop key=<span class="string">&quot;/helloGuest.htm&quot;</span>&gt;helloGuestController&lt;/prop&gt;</span><br><span class="line">         &lt;/props&gt;</span><br><span class="line">       &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean <span class="built_in">id</span>=<span class="string">&quot;welcomeController&quot;</span> </span><br><span class="line">        class=<span class="string">&quot;com.mkyong.common.controller.WController&quot;</span> /&gt;        </span><br><span class="line">    &lt;bean <span class="built_in">id</span>=<span class="string">&quot;helloGuestController&quot;</span> </span><br><span class="line">        class=<span class="string">&quot;com.mkyong.common.controller.HController&quot;</span> /&gt;     </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p><strong>value方式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans ...&gt; </span><br><span class="line">    &lt;bean class=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;mappings&quot;</span>&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">           /welcome.htm=welcomeController</span><br><span class="line">           /*/welcome.htm=welcomeController</span><br><span class="line">           /helloGuest.htm=helloGuestController</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">       &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean <span class="built_in">id</span>=<span class="string">&quot;welcomeController&quot;</span> </span><br><span class="line">        class=<span class="string">&quot;com.mkyong.common.controller.WController&quot;</span> /&gt;        </span><br><span class="line">    &lt;bean <span class="built_in">id</span>=<span class="string">&quot;helloGuestController&quot;</span> </span><br><span class="line">        class=<span class="string">&quot;com.mkyong.common.controller.HController&quot;</span> /&gt;           </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p><strong>map填入entry键值对</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans ...&gt; </span><br><span class="line">...</span><br><span class="line">&lt;property name=<span class="string">&quot;mappings&quot;</span>&gt;</span><br><span class="line">    &lt;map&gt;</span><br><span class="line">        &lt;entry key=<span class="string">&quot;/welcome&quot;</span> value=<span class="string">&quot;welcomeController&quot;</span> /&gt;</span><br><span class="line">        &lt;entry key=<span class="string">&quot;/hello&quot;</span> value=<span class="string">&quot;helloGuestController&quot;</span> /&gt;</span><br><span class="line">        &lt;entry key=<span class="string">&quot;/hi&quot;</span> value=<span class="string">&quot;helloLuBanController&quot;</span> /&gt;</span><br><span class="line">        &lt;entry key=<span class="string">&quot;/login&quot;</span> value=<span class="string">&quot;loginHttpServlet&quot;</span> /&gt;</span><br><span class="line">    &lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p><strong>properties 配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans ...&gt; </span><br><span class="line">...</span><br><span class="line">&lt;property name=<span class="string">&quot;mappings&quot;</span>&gt;</span><br><span class="line">	&lt;bean class=<span class="string">&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;location&quot;</span> value=<span class="string">&quot;classpath:spring/url-mapping.properties&quot;</span>/&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"> ...</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>url-mapping.properties:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/welcome = welcomeController</span><br><span class="line">/hello = helloGuestController</span><br><span class="line">/hi = helloLuBanController</span><br><span class="line">/login = loginHttpServlet</span><br></pre></td></tr></table></figure>

<h3 id="6-RequestMappingHandlerMapping"><a href="#6-RequestMappingHandlerMapping" class="headerlink" title="6.RequestMappingHandlerMapping"></a>6.RequestMappingHandlerMapping</h3><p>
&emsp;&emsp;
顾名思义就是针对@RequestMapping注解。如果想要 RequestMapping 注解生效，必须在 xml 文件中配置< mvc:annotation-driven/>。
</p>

<p>【扩展】RequestMapping注解</p>
<ul>
<li>value属性<br>@RequestMapping(value &#x3D;”&#x2F;example”)：一对一<br>@RequestMapping(value &#x3D; {“&#x2F;page1”,”&#x2F;page2”,”&#x2F;page3”})：多对一</li>
<li>name<br>注释，使方法更易理解.</li>
<li>method 属性<br>用于表示该方法支持哪些 HTTP 请求，例如:<br>@RequestMapping(method &#x3D; RequestMethod.GET)<br>@RequestMapping(method &#x3D; {RequestMethod.GET, RequestMethod.DELETE})<br>请求方式不符合会报错.</li>
<li>params 属性（了解）<br> 要求所匹配的请求是否必须携带 param 参数，并且可以指定携带参数的值.</li>
<li>consumers 属性（了解）<br>用于指定处理请求的提交内容类型（Content-Type），例如：application&#x2F;json、text&#x2F;html.</li>
<li>header 属性（了解）<br>要求所匹配的请求是否必须携带请求头信息，并且可以指定请求头信息的值.</li>
</ul>
<p>【扩展】spring支持ant风格路径<br>（1）?：表示任意单个字符<br>（2）*：表示任意0个或多个字符<br>（3）**：表示0或多层目录（只能用&#x2F;**&#x2F;xxx的方式，不然就是*的效果）<br>实例:<br>@RequestMapping(“a?a&#x2F;test”)<br>localhost:8080&#x2F;springmvc&#x2F;aaa&#x2F;test<br>localhost:8080&#x2F;springmvc&#x2F;aba&#x2F;test</p>
<p>@RequestMapping(“a*a&#x2F;test”)<br>localhost:8080&#x2F;springmvc&#x2F;aaa&#x2F;test<br>localhost:8080&#x2F;springmvc&#x2F;abcda&#x2F;test</p>
<p>@RequestMapping(“&#x2F;**&#x2F;test”)<br>localhost:8080&#x2F;springmvc&#x2F;test<br>localhost:8080&#x2F;springmvc&#x2F;a&#x2F;a&#x2F;a&#x2F;test</p>
<h1 id="五-HandlerAdapter"><a href="#五-HandlerAdapter" class="headerlink" title="五.HandlerAdapter"></a>五.HandlerAdapter</h1><h2 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h2><p>
&emsp;&emsp;
根据 Handler 来找到支持它的 HandlerAdapter，通过 HandlerAdapter 执行这个 Handler 得到 ModelAndView 对象。dispatcherServlet就是通过这个接口来访问handler的，而不是直接去访问真正的实际的处理器，这样做的好处是：处理器程序允许是任意的Object；集成第三方请求处理器的时候，本处代码也无需修改。此接口不适用于应用程序开发人员。
</p>

<h2 id="2-为何需要使用HandlerAdapter适配"><a href="#2-为何需要使用HandlerAdapter适配" class="headerlink" title="2.为何需要使用HandlerAdapter适配"></a>2.为何需要使用HandlerAdapter适配</h2><p>
&emsp;&emsp;
Spring MVC的Handler（Controller接口，HttpRequestHandler，Servlet、@RequestMapping）有四种表现形式，在Handler不确定是什么方式的时候（可能是方法、也可能是类），适配器这种设计模式就能模糊掉具体的实现，从而就能提供统一访问接口。<br>
&emsp;&emsp;
处理器Handler需要程序员去写代码处理逻辑的，而处理器适配器（HandlerAdapter）会把处理器包装成适配器，这样就可以支持多种类型的处理器。
</p>

<h2 id="3-与HandlerMapping区别"><a href="#3-与HandlerMapping区别" class="headerlink" title="3.与HandlerMapping区别"></a>3.与HandlerMapping区别</h2><p>
（1）HandlerMapping的作用主要是根据request请求匹配/映射上能够处理当前request的handler。<br>
（2）HandlerAdapter的作用在于将request中的各个属性，如request param适配为handler能够处理的形式，参数绑定、数据校验、内容协商…几乎所有的web层问题都在在这里完成的。
</p>

<h2 id="4-实现类"><a href="#4-实现类" class="headerlink" title="4.实现类"></a>4.实现类</h2><img src="\images\pic6.png" width= 800 height=150 />
<p>
&emsp;&emsp;
重点是 RequestMappingHandlerAdapter，作为适配 @RequestMapping 注解标注的 Handler，它是自 Spring3.1 新增的一个适配器类，拥有数据绑定、数据转换、数据校验、内容协商…等一系列非常高级的功能。
</p>

<h1 id="六-SpringMVC中请求参数的接收"><a href="#六-SpringMVC中请求参数的接收" class="headerlink" title="六.SpringMVC中请求参数的接收"></a>六.SpringMVC中请求参数的接收</h1><h2 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h2><p>
&emsp;&emsp;
对于 HttpServletRequest 和 HttpServletResponse，我们可以调用 getInputStream 和 getOutputStream 来直接获取请求信息，不过返回值只是一段字符串，对于开发人员来说，处理一个对象肯定比处理一个字符串要方便得多，也好理解得多，所以对数据的封装转换是不可避免的事。<br>
&emsp;&emsp;
SpringMVC通过反射的方式调用Controller的方法，然后将请求的参数解析，并和方法的形参做匹配并传递过去。一般的表单或者JSON数据的请求都是相对简单的，一些复杂的处理主要包括日期、URL路径参数、文件上传、数组或者列表类型数据等。<br>
&emsp;&emsp;
SpringMVC 中处理控制器参数的接口是 HandlerMethodArgumentResolver ，此接口有众多子类，分别处理不同（注解类型）的参数。
</p>

<h2 id="2-HandlerMethodArgumentResolver"><a href="#2-HandlerMethodArgumentResolver" class="headerlink" title="2.HandlerMethodArgumentResolver"></a>2.HandlerMethodArgumentResolver</h2><h3 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><p>
&emsp;&emsp;
接口：用于在给定请求的上下文中将方法参数解析为参数值。简单的理解为：它负责处理你Handler方法里的所有入参：包括自动封装、自动赋值、校验等等。Spring MVC 内置了非常多的实现类，当然你还可以自定义和注册。<br>
&emsp;&emsp;
有个形象的公式：HandlerMethodArgumentResolver = HandlerMethod + Argument(参数) + Resolver(解析器)
</p>

<h3 id="（2）源码"><a href="#（2）源码" class="headerlink" title="（2）源码"></a>（2）源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface HandlerMethodArgumentResolver &#123;</span><br><span class="line">    boolean	supportsParameter(MethodParameter parameter);</span><br><span class="line">    Object 	resolveArgument(MethodParameter parameter, ...) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>supportsParameter（支持参数）：可以设置一些标志，表示你这个分解器可以处理这些参数，返回ture才执行resolveArgument()函数</li>
<li>resolveArgument：真正用于处理参数分解的方法，返回的Object就是controller方法上的形参对象。</li>
</ul>
<p>PS：ArgumentResolver在初始化时有一个默认的顺序，如果多个ArgumentResolver可以解析某一种类型，以顺序在前面的先解析。</p>
<h3 id="（3）常见的-HandlerMethodArgumentResolver实现类"><a href="#（3）常见的-HandlerMethodArgumentResolver实现类" class="headerlink" title="（3）常见的 HandlerMethodArgumentResolver实现类"></a>（3）常见的 HandlerMethodArgumentResolver实现类</h3><h4 id="RequestParamMethodArgumentResolver"><a href="#RequestParamMethodArgumentResolver" class="headerlink" title="RequestParamMethodArgumentResolver"></a>RequestParamMethodArgumentResolver</h4><p>
&emsp;&emsp;
  参数需使用 @RequestParam 标注，且 name 属性有值，参数通常为普通类型、Map 类型；或 MultipartFile、Part 类型，或 MultipartFile、Part 这两种类型的集合、数组。<br>
&emsp;&emsp;
【扩】RequestParam 注解<br>
&emsp;&emsp;
value：参数名字，即入参的请求参数名字。指定 value 值时，可以获取request中指定参数的值，可以解决前后端参数名称不一致。未指定 value 值，如果参数类型为 Map 或 MultiValueMap 时，用来接收request中所有参数的值。<br>
&emsp;&emsp;
required：默认为 true，如果前台不传递此参数，后台会报错404。如果设置为 false，如果不传，默认为 null。<br>
&emsp;&emsp;
defaultValue：默认参数值，如果设置了该值，required=true将失效，自动为false。<br>
</p>
 
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(<span class="string">&quot;/test1&quot;</span>)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Map&lt;String, Object&gt; test1(@RequestParam(<span class="string">&quot;rqname&quot;</span>) String name,</span><br><span class="line">                           @RequestParam(<span class="string">&quot;rqage&quot;</span>) int age,</span><br><span class="line">                           @RequestParam(<span class="string">&quot;rqp1&quot;</span>) String[] p1Map,</span><br><span class="line">                           @RequestParam Map&lt;String, String&gt; requestParams1,</span><br><span class="line">                           @RequestParam MultiValueMap requestParams2)&#123;</span><br><span class="line">    Map&lt;String, Object&gt; result = new LinkedHashMap&lt;&gt;();</span><br><span class="line">    result.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    result.put(<span class="string">&quot;age&quot;</span>, age);</span><br><span class="line">    result.put(<span class="string">&quot;p1Map&quot;</span>, p1Map);</span><br><span class="line">    result.put(<span class="string">&quot;requestParams1&quot;</span>, requestParams1);</span><br><span class="line">    result.put(<span class="string">&quot;requestParams2&quot;</span>, requestParams2);</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RequestParamMapMethodArgumentResolver"><a href="#RequestParamMapMethodArgumentResolver" class="headerlink" title="RequestParamMapMethodArgumentResolver"></a>RequestParamMapMethodArgumentResolver</h4><p>
&emsp;&emsp;
  参数需使用 @RequestParam 标注，且 name 属性没有值，参数为 Map 类型；参数的值从 request 的参数中取值，Map 中的 key 对应参数名称，value 对应参数的值
</p>

<h4 id="PathVariableMapMethodArgumentResolver"><a href="#PathVariableMapMethodArgumentResolver" class="headerlink" title="PathVariableMapMethodArgumentResolver"></a>PathVariableMapMethodArgumentResolver</h4><p>
&emsp;&emsp;
  参数需使用@PathVariable 标注，参数通常为基本类型
</p>

<h4 id="RequestHeaderMethodArgumentResolver"><a href="#RequestHeaderMethodArgumentResolver" class="headerlink" title="RequestHeaderMethodArgumentResolver"></a>RequestHeaderMethodArgumentResolver</h4><p>
&emsp;&emsp;
  参数需使用@RequestHeader 标注，参数通常为 Map、MultiValueMap、HttpHeaders 类型<br>
&emsp;&emsp;
【扩】@RequestHeader注解<br>
&emsp;&emsp;
将HTTP请求头中的变量值映射到控制器的参数中（比如Host、From、User-Agent等），参数：value，required，defaultValue，用法同@RequestParam。
</p>

<h4 id="ServletCookieValueMethodArgumentResolver"><a href="#ServletCookieValueMethodArgumentResolver" class="headerlink" title="ServletCookieValueMethodArgumentResolver"></a>ServletCookieValueMethodArgumentResolver</h4><p>
&emsp;&emsp;
  参数需使用@CookieValue 标注，参数为普通类型或者 Cookie 类型
</p>

<h4 id="ModelMethodProcessor"><a href="#ModelMethodProcessor" class="headerlink" title="ModelMethodProcessor"></a>ModelMethodProcessor</h4><p>
&emsp;&emsp;
  参数为 Model 类型，控制器中可以调用 model.addAttribute 想模型中放数据，最终这些数据都会通过 request.setAttribute 复制到 request 中
</p>

<h4 id="MapMethodProcessor"><a href="#MapMethodProcessor" class="headerlink" title="MapMethodProcessor"></a>MapMethodProcessor</h4><p>
&emsp;&emsp;
  处理参数为 Map 类型，但没有标注任何注解的情况，它的执行顺序是很靠后的，所以有点兜底的意思。这个处理器同时也解释了：为何你方法入参上写个Map、Model及ModelMap （都是org.springframework.validation.support.BindingAwareModelMap类型）等等就可以非常便捷的获取到模型的值。
</p>

<h4 id="RequestAttributeMethodArgumentResolver"><a href="#RequestAttributeMethodArgumentResolver" class="headerlink" title="RequestAttributeMethodArgumentResolver"></a>RequestAttributeMethodArgumentResolver</h4><p>
&emsp;&emsp;
  参数需使用@RequestAttribute
</p>

<h4 id="SessionAttributeMethodArgumentResolver"><a href="#SessionAttributeMethodArgumentResolver" class="headerlink" title="SessionAttributeMethodArgumentResolver"></a>SessionAttributeMethodArgumentResolver</h4><p>
&emsp;&emsp;
  参数需使用@SessionAttribute
</p>

<h4 id="ServletModelAttributeMethodProcessor"><a href="#ServletModelAttributeMethodProcessor" class="headerlink" title="ServletModelAttributeMethodProcessor"></a>ServletModelAttributeMethodProcessor</h4><p>
&emsp;&emsp;
  为我们自定义的 javabean 赋值
</p>

<h4 id="RequestResponseBodyMethodProcessor"><a href="#RequestResponseBodyMethodProcessor" class="headerlink" title="RequestResponseBodyMethodProcessor"></a>RequestResponseBodyMethodProcessor</h4><p>
&emsp;&emsp;
  参数需使用@RequestBody 标注
</p>

<h3 id="（4）HandlerMethodArgumentResolver实现类-固定参数类型"><a href="#（4）HandlerMethodArgumentResolver实现类-固定参数类型" class="headerlink" title="（4）HandlerMethodArgumentResolver实现类 - 固定参数类型"></a>（4）HandlerMethodArgumentResolver实现类 - 固定参数类型</h3><p>
&emsp;&emsp;
参数是SessionStatus, ServletResponse, OutputStream, Writer, WebRequest, MultipartRequest, HttpSession, Principal, InputStream等。
</p>

<h4 id="ServletRequestMethodArgumentResolver"><a href="#ServletRequestMethodArgumentResolver" class="headerlink" title="ServletRequestMethodArgumentResolver"></a>ServletRequestMethodArgumentResolver</h4><h4 id="ServletResponseMethodArgumentResolver"><a href="#ServletResponseMethodArgumentResolver" class="headerlink" title="ServletResponseMethodArgumentResolver"></a>ServletResponseMethodArgumentResolver</h4><h4 id="ModelMethodProcessor-1"><a href="#ModelMethodProcessor-1" class="headerlink" title="ModelMethodProcessor"></a>ModelMethodProcessor</h4><p>
（1）作用<br>
处理被@ModelAttribute注解修饰且不是普通类型的参数。@ModelAttribute用来将请求参数绑定到 Model 对象。<br>
（2）应用<br>
@RequestAttribute只负责从request里面取属性值，至于你什么时候往里放值，是有多种方式的可以达到的：<br>
[1] @ModelAttribute注解预存<br>
[2] HandlerInterceptor拦截器中预存<br>
[3] 请求转发带过来（上面说过了）<br>
</p>
（3）实例
【@ModelAttribute注解预存】
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ModelAttribute</span><br><span class="line">public Person personModelAttr(HttpServletRequest request) &#123;</span><br><span class="line">     request.setAttribute(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;fsx-application&quot;</span>);</span><br><span class="line">     <span class="built_in">return</span> new Person(<span class="string">&quot;非功能方法&quot;</span>, 50);</span><br><span class="line">&#125;</span><br><span class="line">@GetMapping(<span class="string">&quot;/testRequestAttr&quot;</span>)</span><br><span class="line">public void <span class="built_in">test</span>(@RequestAttribute(<span class="string">&quot;aaa&quot;</span>) String str, HttpServletRequest request)&#123;</span><br><span class="line">     System.out.println(str);</span><br><span class="line"></span><br><span class="line">      //和从request里获取是一样的</span><br><span class="line">      //System.out.println(request.getAttribute(<span class="string">&quot;aaa&quot;</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
【拦截器中预存】
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;myApplicationName&quot;</span>, <span class="string">&quot;fsx-application&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>
【扩展】request.getParameter() 和request.getAttribute() 区别<br>
&emsp;&emsp;request.getParameter()取得是通过容器的实现来取得通过类似post，get等方式传入的数据;而request.setAttribute()和getAttribute()只是在web容器内部流转，仅仅是请求处理阶段。
</p>

<h3 id="（5）HandlerMethodArgumentResolver实现类-基于ContentType消息转换器类型"><a href="#（5）HandlerMethodArgumentResolver实现类-基于ContentType消息转换器类型" class="headerlink" title="（5）HandlerMethodArgumentResolver实现类 - 基于ContentType消息转换器类型"></a>（5）HandlerMethodArgumentResolver实现类 - 基于ContentType消息转换器类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractMessageConverterMethodArgumentResolver implements HandlerMethodArgumentResolver &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RequestPartMethodArgumentResolver"><a href="#RequestPartMethodArgumentResolver" class="headerlink" title="RequestPartMethodArgumentResolver"></a>RequestPartMethodArgumentResolver</h4><h4 id="AbstractMessageConverterMethodProcessor（重点）"><a href="#AbstractMessageConverterMethodProcessor（重点）" class="headerlink" title="AbstractMessageConverterMethodProcessor（重点）"></a>AbstractMessageConverterMethodProcessor（重点）</h4><h4 id="RequestResponseBodyMethodProcessor-1"><a href="#RequestResponseBodyMethodProcessor-1" class="headerlink" title="RequestResponseBodyMethodProcessor"></a>RequestResponseBodyMethodProcessor</h4><h4 id="HttpEntityMethodProcessor"><a href="#HttpEntityMethodProcessor" class="headerlink" title="HttpEntityMethodProcessor"></a>HttpEntityMethodProcessor</h4><h3 id="（6）自定义ArgumentResolver"><a href="#（6）自定义ArgumentResolver" class="headerlink" title="（6）自定义ArgumentResolver"></a>（6）自定义ArgumentResolver</h3><h2 id="八．SpringMVC接收请求参数所有方式总结"><a href="#八．SpringMVC接收请求参数所有方式总结" class="headerlink" title="八．SpringMVC接收请求参数所有方式总结"></a>八．SpringMVC接收请求参数所有方式总结</h2><p>一般来说有四种：普通类型，pojo，数组，集合。</p>
<h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/16/Spring%E7%B3%BB%E5%88%971/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alexior">
      <meta itemprop="description" content="蓦然回首，那是我们逝去的青春">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Human Instrumentality Project">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/16/Spring%E7%B3%BB%E5%88%971/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-16 22:19:00" itemprop="dateCreated datePublished" datetime="2023-03-16T22:19:00+08:00">2023-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-17 19:19:57" itemprop="dateModified" datetime="2023-03-17T19:19:57+08:00">2023-03-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一．Spring-简介"><a href="#一．Spring-简介" class="headerlink" title="一．Spring 简介"></a>一．Spring 简介</h1><p>
&emsp;&emsp;spring是一个java企业级开发框架，包含了诸多技术，包括：控制反转、依赖注入、面向切面编程（核心概念）等，同时还有spring事务管理、通过spring集成其他框架、springmvc、springboot、springcloud这些简化开发的技术。<br>
&emsp;&emsp;
Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。为了降低Java开发的复杂性，Spring采取了以下4种关键策略：<br>
&emsp;&emsp;（1）基于POJO的轻量级和最小侵入性编程；<br>
&emsp;&emsp;（2）通过依赖注入和面向接口实现松耦合；<br>
&emsp;&emsp;（3）基于切面和惯例进行声明式编程；<br>
&emsp;&emsp;（4）通过切面和模板减少样板式代码；
</p>

<h1 id="二．总体架构"><a href="#二．总体架构" class="headerlink" title="二．总体架构"></a>二．总体架构</h1><img src="\images\pic5.png" width= 700 height=512 />

<ol>
<li>核心容器（Core Container）<p>
&emsp;&emsp;Core 模块提供核心工具类给其他模块使用，主要组件是 BeanFactory，用来创建和管理bean对象的实例，是简单工厂模式的体现；<br>
&emsp;&emsp;Bean 模块是负责对 Spring bean 的创建管理及注入等（Spring bean 默认是单例模式）；<br>
&emsp;&emsp;Context 模块是一个配置文件，为 Spring 框架提供上下文信息。Context 模块基于前两者提供了大量扩展功能，包括对国际化、资源加载等；<br>
&emsp;&emsp;Expression Language 模块提供了强大的表达式语言，用于运行时查询和操作对象。
</p></li>
<li>Spring面向切面编程（Spring AOP）<p>
&emsp;&emsp;提供了一个符合AOP联盟标准的面向切面编程的实现，Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术，简单来说就是代理模式。通过使用 Spring AOP就不用依赖 EJB 组件，将声明性事务管理集成到应用程序中。</p></li>
<li>数据访问&#x2F;集成模块（Data Access&#x2F;Integration）<p>
&emsp;&emsp;
JDBC（Java Database connect）：该模块提供了 Spring 对 JDBC 访问的封装。<br>
&emsp;&emsp;
ORM（Object Relational Mapping)：对象关系映射 API，把对象模型表示对象映射到关系Sql数据库，如JPA、Hibernate等。<br>
&emsp;&emsp;
OXM：为主流Object/Xml Mapping组件提供了统一层抽象和封装，默认提供目前几个主流O/X Mapping组件的实现，包括XStream，XMLBeans，Castor，JiBX，JAXB。<br>
&emsp;&emsp;
JMS（Java Message Service）：java消息服务，用于生产和消费消息的功能。<br>
&emsp;&emsp;
Transaction ：事务模块。
</p></li>
<li>Web模块（Spring Web）<p>
&emsp;&emsp;
Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。
</p></li>
<li>Spring Test<p>
&emsp;&emsp;
主要为测试提供支持的，支持使用 JUnit 或 TestNG 对 Spring 组件进行单元测试和集成测试。
</p></li>
</ol>
<h1 id="三．IOC-Inversion-of-Control-控制反转"><a href="#三．IOC-Inversion-of-Control-控制反转" class="headerlink" title="三．IOC-Inversion of Control 控制反转"></a>三．IOC-Inversion of Control 控制反转</h1><h2 id="1-思想"><a href="#1-思想" class="headerlink" title="1.思想"></a>1.思想</h2><p>
&emsp;&emsp;
由容器来创建对象（通过读取xml然后反射创建对象），IOC的底层就是对象工厂。
</p>

<h2 id="2-IOC容器实现（两个接口）"><a href="#2-IOC容器实现（两个接口）" class="headerlink" title="2.IOC容器实现（两个接口）"></a>2.IOC容器实现（两个接口）</h2><h3 id="（1）BeanFactory"><a href="#（1）BeanFactory" class="headerlink" title="（1）BeanFactory"></a>（1）BeanFactory</h3><p>
&emsp;&emsp;
spring内部接口，不提供给开发人员使用，加载配置文件的时候不会去创建对象，在获取（使用）对象的时候才会去创建对象。
</p>

<h3 id="（2）ApplicationContext"><a href="#（2）ApplicationContext" class="headerlink" title="（2）ApplicationContext"></a>（2）ApplicationContext</h3><p>
&emsp;&emsp;
BeanFactory的子接口，提供更多强大的功能，一般由开发人员进行使用，加载配置文件的时候就创建对象。
ApplicationContext接口常用实现类：
</p>

<ul>
<li>AnnotationConfigApplicationContext	<br>从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式。</li>
<li>ClassPathXmlApplicationContext	<br>从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式。</li>
<li>FileSystemXmlApplicationContext	<br>从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件。</li>
<li>AnnotationConfigWebApplicationContext	<br>专门为web应用准备的，适用于注解方式。</li>
<li>XmlWebApplicationContext	<br>从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。</li>
</ul>
<h1 id="四．DI-Dependency-Injection"><a href="#四．DI-Dependency-Injection" class="headerlink" title="四．DI-Dependency Injection"></a>四．DI-Dependency Injection</h1><h2 id="1-Dependency-Injection"><a href="#1-Dependency-Injection" class="headerlink" title="1.Dependency Injection"></a>1.Dependency Injection</h2><p>
&emsp;&emsp;
依赖注入是一种消除类之间依赖关系的设计模式。例如，A类要依赖B类，以前我们是直接在A类new一个B类，而现在是则把这种依赖关系写在xml配置文件，然后由Spring容器根据配置信息来创建、管理bean类，通过容器把B类注入到A类里。
</p>

<h2 id="2-注入方式"><a href="#2-注入方式" class="headerlink" title="2.注入方式"></a>2.注入方式</h2><p>主要有三种：构造方法注入（Construct注入），setter注入，基于注解的注入（接口注入）。</p>
<h3 id="（1）构造方法注入"><a href="#（1）构造方法注入" class="headerlink" title="（1）构造方法注入"></a>（1）构造方法注入</h3><p>① 根据构造器参数索引注入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;xxx&quot;</span> class=<span class="string">&quot;xxx&quot;</span>&gt;</span><br><span class="line">  &lt;constructor-arg index=<span class="string">&quot;0&quot;</span> value=<span class="string">&quot;xxx&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>
&emsp;&emsp;
参数位置的注入对参数顺序有很强的依赖性，若构造函数参数位置被人调整过，会导致注入出错。不过通常情况下，不建议去在代码中修改构造函数，如果需要新增参数的，可以新增一个构造函数来实现，这算是一种扩展，不会影响目前已有的功能。
</p>
②根据构造器参数类型注入
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;xxx&quot;</span> class=<span class="string">&quot;xxx&quot;</span>&gt;</span><br><span class="line">  &lt;constructor-arg <span class="built_in">type</span>=<span class="string">&quot;参数类型&quot;</span> value=<span class="string">&quot;xxx&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>
&emsp;&emsp;
实际上按照参数位置或者按照参数的类型注入，都有一个问题，很难通过bean的配置文件，知道这个参数是对应UserModel中的那个属性的，代码的可读性不好。
</p>
③根据构造器参数名称注入
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;xxx&quot;</span> class=<span class="string">&quot;xxx&quot;</span>&gt;</span><br><span class="line">  &lt;constructor-arg name=<span class="string">&quot;参数名&quot;</span> value=<span class="string">&quot;xxx&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>
&emsp;&emsp;
java通过反射的方式可以获取到方法的参数名称，不过源码中的参数通过编译之后会变成class对象，通常情况下源码变成class文件之后，参数的真实名称会丢失，参数的名称会变成arg0,arg1,arg2这样的，和实际参数名称不一样了。spring提供了解决方案，通过ConstructorProperties注解来定义参数的名称，将这个注解加在构造方法上面：<br>
&emsp;&emsp;
@ConstructorProperties({"第一个参数名称", ... "第n个参数的名称"})
</p>

<h3 id="（2）set注入"><a href="#（2）set注入" class="headerlink" title="（2）set注入"></a>（2）set注入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.my.spring.dao.impl.userDao&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">&quot;XXX&quot;</span> ref=<span class="string">&quot;userDao&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt; </span><br><span class="line"></span><br><span class="line">public class UserService&#123;</span><br><span class="line">   		...</span><br><span class="line">    public void setXXX(userDao ud) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>
&emsp;&emsp;
当然还可以注入其他类型如String、list、set、map、array、props（相当于键值都是String类型的Map），注意property标签里的ref要换成value。
</p>

<h3 id="（3）基于注解"><a href="#（3）基于注解" class="headerlink" title="（3）基于注解"></a>（3）基于注解</h3><p>注册bean注解：</p>
<ul>
<li>@Component：可以用于注册所有bean</li>
<li>@Repository：主要用于注册dao层的bean</li>
<li>@Controller：主要用于注册控制层的bean</li>
<li>@Service：主要用于注册服务层的bean<br>注入：</li>
<li>@Autowired<br>有三个属性：Constructor，byType，byName。默认按照byType注入。</li>
</ul>
<h2 id="3-自动注入"><a href="#3-自动注入" class="headerlink" title="3.自动注入"></a>3.自动注入</h2><p>xml中可以在bean元素中通过autowire属性来设置自动注入的方式（还可以使用手动的方式自动注入进行覆盖，手动的优先级更高一些）：<br><code>&lt;bean id=&quot;&quot; class=&quot;xxx&quot; autowire=&quot;byType|byName|constructor|default&quot; /&gt;</code></p>
<ul>
<li>byteName：按照名称进行注入</li>
<li>byType：按类型进行注入</li>
<li>constructor：按照构造方法进行注入</li>
<li>default：默认注入方式</li>
</ul>
<h1 id="五．bean"><a href="#五．bean" class="headerlink" title="五．bean"></a>五．bean</h1><p>
&emsp;&emsp;
Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中的形式定义或通过注解定义。
</p>

<h2 id="1-bean的实例化"><a href="#1-bean的实例化" class="headerlink" title="1.bean的实例化"></a>1.bean的实例化</h2><p>由spring容器管理的对象统称为Bean对象。Bean就是普通的java对象。<br>（1）通过反射调用构造方法创建<br>（2）静态工厂实例化<br>（3）实例工厂实例化<br>（4）通过FactoryBean创建bean对象创建方式</p>
<h2 id="2-bean名称别名"><a href="#2-bean名称别名" class="headerlink" title="2.bean名称别名"></a>2.bean名称别名</h2><p>名称和别名可以通过bean元素中的id和name来定义，我们可以通过ClassPathXmlApplicationContext中两个方法来获取bean的名称和别名：getBeanDefinitionNames() 和 getAliases(String beanName)，具体定义规则如下：<br>（1）当id存在的时，取id为bean的名称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;asd0&quot;</span> name=<span class="string">&quot;asd1,asd2,asd3&quot;</span> class=<span class="string">&quot;...&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>名称：asd0，别名：asd1,asd2,asd3<br>（2）当id不存在时，如果name存在（可通过分隔符分割），会按照分隔符得到一个String数组，数组的第一个元素作为bean的名称，其他作为bean的别名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;asd1,asd2,asd3&quot;</span> class=<span class="string">&quot;...&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>名称：asd1，别名：asd2,asd3<br>（3）当id和name都不存在时，bean名称自动生成（bean的class的<strong>完整类名#编号</strong>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;class=<span class="string">&quot;xxx&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>名称：xxx#0，别名：xxx<br>（4）我们还可以通过alias标签来给某个bean定义别名，以下两种写法效果一样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;asd0&quot;</span> name=<span class="string">&quot;asd1,asd2&quot;</span> class=<span class="string">&quot;...&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;asd0&quot;</span> class=<span class="string">&quot;...&quot;</span>/&gt;</span><br><span class="line">&lt;<span class="built_in">alias</span> name=<span class="string">&quot;asd0&quot;</span> <span class="built_in">alias</span>=<span class="string">&quot;asd1&quot;</span>&gt;&lt;/alias&gt;</span><br><span class="line">&lt;<span class="built_in">alias</span> name=<span class="string">&quot;asd0&quot;</span> <span class="built_in">alias</span>=<span class="string">&quot;asd2&quot;</span>&gt;&lt;/alias&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-bean作用域"><a href="#3-bean作用域" class="headerlink" title="3.bean作用域"></a>3.bean作用域</h2><table>
<thead>
<tr>
<th>作用域</th>
<th align="center">详细</th>
</tr>
</thead>
<tbody><tr>
<td>singleton（默认）</td>
<td align="center">在每个spring容器中只有一个bean实例</td>
</tr>
<tr>
<td>prototype</td>
<td align="center">每次从容器中getBean()时，都返回一个新的实例，如果bean比较复杂，创建时间比长，则会影响系统的性能</td>
</tr>
<tr>
<td>request</td>
<td align="center">表示一次http请求对应一个bean实例，该 bean 仅在当前 HTTP request 内有效</td>
</tr>
<tr>
<td>session</td>
<td align="center">表示每个会话会对应一个bean实例，该 bean 仅在当前 HTTP session 内有效</td>
</tr>
<tr>
<td>application</td>
<td align="center">表示一个web应用程序对应一个bean实例</td>
</tr>
<tr>
<td>自定义</td>
<td align="center">通过继承scope接口来自定义bean的作用域</td>
</tr>
</tbody></table>
<p>
【注】Spring 框架并没有对单例 bean 进行多线程的封装处理，因此Spring框架中的单例bean不是线程安全的。
&emsp;&emsp;
实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域为 prototype。<br>
&emsp;&emsp;
【扩】无状态就是不会保存数据，反过来有状态就是有数据存储功能。
</p>

<h2 id="4-延迟初始化（了解）"><a href="#4-延迟初始化（了解）" class="headerlink" title="4.延迟初始化（了解）"></a>4.延迟初始化（了解）</h2><p>延迟初始化的bean在容器启动过程中不会创建，而是需要使用的时候才会去创建：<br><bean lazy-init="true/false" /><br>用来解决定义的bean过多或过于复杂，创建耗时。</p>
<h2 id="5-在容器匹配到多个bean问题"><a href="#5-在容器匹配到多个bean问题" class="headerlink" title="5.在容器匹配到多个bean问题"></a>5.在容器匹配到多个bean问题</h2><p>（1）primary（选择法）<br>当希望从容器中获取到一个bean对象的时候，容器中却找到了多个匹配的bean，此时spring不知道如何选择了，处于懵逼状态，就会报这个异常。<br>spring中可以通过bean元素的primary属性来解决这个问题，可以通过这个属性来指定当前bean为主要候选者，当容器查询一个bean的时候，如果容器中有多个候选者匹配的时候，此时spring会返回主要的候选者。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;serviceA&quot;</span> class=<span class="string">&quot;xxx&quot;</span> primary=<span class="string">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>（2）排除法<br>还有一种方法也可以解决这个问题，可以设置某个bean是否在自动注入的时候是否为作为候选bean（默认值是true）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;serviceA&quot;</span> class=<span class="string">&quot;xxx&quot;</span> autowire-candidate=<span class="string">&quot;false&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>（3）当然也可以两个结合使用</p>
<h2 id="6-Spring-Bean-的生命周期（重点）"><a href="#6-Spring-Bean-的生命周期（重点）" class="headerlink" title="6.Spring Bean 的生命周期（重点）"></a>6.<a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/118500805">Spring Bean 的生命周期（重点）</a></h2><h2 id="7-单例Bean中使用多例Bean"><a href="#7-单例Bean中使用多例Bean" class="headerlink" title="7.单例Bean中使用多例Bean"></a>7.<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1671333">单例Bean中使用多例Bean</a></h2><h1 id="六．代理"><a href="#六．代理" class="headerlink" title="六．代理"></a>六．代理</h1><h2 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1.静态代理"></a>1.静态代理</h2><p>在不改变原业务代码的情况下添加业务功能，但是代码量多。</p>
<h2 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2.动态代理"></a>2.动态代理</h2><p>（1）简述</p>
<p>
&emsp;&emsp;
代理spring中用到的挺多的，比如lookup-method和replaced-method，以及aop、spring中的事务、spring中解析@configuration注解等等，这些都是依靠代理来实现的。
</p>
（2）动态代理技术的实现方式
<p>
&emsp;&emsp;
基于接口的 JDK 动态代理；<br>
&emsp;&emsp;
基于继承的 CGLib 动态代理；
</p>

<h1 id="七．AOP"><a href="#七．AOP" class="headerlink" title="七．AOP"></a>七．AOP</h1><p>
&emsp;&emsp;
AOP（Aspect Oriented Programming）：面向切面编程，它是一种思想，它是对某一类事情的集中处理，AOP 可以说是 OOP（Object Oriented Programming，面向对象编程）的补充和完善。Spring AOP 是通过动态代理技术实现的，而动态代理是基于反射设计的。<br>
&emsp;&emsp;
AOP 可以实现：统一用户登录判断、统一日志记录、统一方法执行时间统计、统一的返回格式设置、统一的异常处理、事务的开启和提交等。
</p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/16/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alexior">
      <meta itemprop="description" content="蓦然回首，那是我们逝去的青春">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Human Instrumentality Project">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/16/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-16 00:35:33" itemprop="dateCreated datePublished" datetime="2023-03-16T00:35:33+08:00">2023-03-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alexior</p>
  <div class="site-description" itemprop="description">蓦然回首，那是我们逝去的青春</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alexior</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
